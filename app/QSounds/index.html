<!DOCTYPE html>
<html lang="de" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <title>QSounds v1.6 Ultimate Cyberspace – RSA Encrypting & Sound Tool</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons|Material+Icons+Outlined" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsencrypt/3.3.2/jsencrypt.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/davidshimjs-qrcodejs@0.0.2/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="icon" type="image/svg+xml" href="https://quixoticode.github.io/data/qsounds/favicon.svg" />
    
    <style>
        :root {
            --font-family-sans: 'Roboto', 'Inter', 'Segoe UI', sans-serif;
            --color-primary: #5E35B1;
            --color-primary-variant: #4527A0;
            --color-secondary: #00897B;
            --color-background: #F5F5F5;
            --color-surface: #FFFFFF;
            --color-on-primary: #FFFFFF;
            --color-on-secondary: #FFFFFF;
            --color-on-background: #212121;
            --color-on-surface: #212121;
            --color-on-surface-variant: #616161;
            --color-outline: #E0E0E0;
            --color-error: #D32F2F;
            --color-success: #388E3C;
            --elevation-1: 0 2px 4px rgba(0,0,0,0.05);
            --elevation-2: 0 4px 8px rgba(0,0,0,0.07);
            --elevation-3: 0 10px 20px rgba(0,0,0,0.08);
            --border-radius-medium: 16px;
            --border-radius-large: 28px;
            --border-radius-full: 9999px;
        }

        [data-theme="dark"] {
            --color-primary: #9575CD;
            --color-primary-variant: #7E57C2;
            --color-secondary: #26A69A;
            --color-background: #0a0a0a;
            --color-surface: #1E1E1E;
            --color-on-background: #E0E0E0;
            --color-on-surface: #E0E0E0;
            --color-on-surface-variant: #9E9E9E;
            --color-outline: #424242;
            --color-error: #EF9A9A;
            --color-success: #A5D6A7;
        }

        body { font-family: var(--font-family-sans); background-color: var(--color-background); color: var(--color-on-background); transition: background-color 0.3s, color 0.3s; overflow: hidden; }
        #background-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; display: none; }
        [data-theme="dark"] #background-canvas { display: block; }

        .wizard-step { display: none; }
        .wizard-step.active { display: block; animation: fadeIn 0.5s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        
        .card { background-color: var(--color-surface); border-radius: var(--border-radius-medium); padding: 1.5rem 2rem; box-shadow: var(--elevation-2); transition: box-shadow 0.3s ease-in-out, transform 0.3s ease; border: 1px solid var(--color-outline); }
        .choice-button { background-color: color-mix(in srgb, var(--color-primary) 8%, transparent); border: 1px solid var(--color-outline); color: var(--color-primary); border-radius: var(--border-radius-medium); padding: 1.5rem; text-align: center; transition: all 0.2s ease; cursor: pointer; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        .choice-button:hover { background-color: color-mix(in srgb, var(--color-primary) 15%, transparent); border-color: var(--color-primary); transform: translateY(-3px); box-shadow: var(--elevation-1); }
        .choice-button .material-icons-outlined { font-size: 48px; }
        
        .qs-button { display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem; background-color: var(--color-primary); color: var(--color-on-primary); padding: 0.75rem 1.5rem; border-radius: var(--border-radius-full); font-weight: 500; text-transform: uppercase; letter-spacing: 0.05em; font-size: 0.9rem; border: none; cursor: pointer; transition: all 0.2s ease; box-shadow: var(--elevation-1); }
        .qs-button:hover:not(:disabled) { background-color: var(--color-primary-variant); box-shadow: var(--elevation-2); }
        .qs-button:disabled { background-color: color-mix(in srgb, var(--color-on-surface) 10%, transparent); color: var(--color-on-surface-variant); cursor: not-allowed; box-shadow: none; }
        .qs-button.secondary { background-color: var(--color-secondary); color: var(--color-on-secondary); }
        .qs-button.secondary:hover:not(:disabled) { background-color: color-mix(in srgb, var(--color-secondary) 80%, black); }
        
        .qs-button-text { background: none; border: none; color: var(--color-primary); cursor: pointer; padding: 0.5rem 0.75rem; border-radius: var(--border-radius-full); font-weight: 500; transition: background-color 0.2s; }
        .qs-button-text:hover:not(:disabled) { background-color: color-mix(in srgb, var(--color-primary) 15%, transparent); }
        
        .qs-textarea { background-color: var(--color-surface); color: var(--color-on-surface); border: 1px solid var(--color-outline); border-radius: var(--border-radius-medium); padding: 0.9rem 1rem; width: 100%; font-size: 1rem; line-height: 1.5; transition: border-color 0.2s ease, box-shadow 0.2s ease; }
        .qs-textarea:focus { border-color: var(--color-primary); outline: none; box-shadow: 0 0 0 3px color-mix(in srgb, var(--color-primary) 25%, transparent); }
        
        #toast-container { position: fixed; bottom: 1.5rem; right: 1.5rem; z-index: 2000; display: flex; flex-direction: column; gap: 0.75rem; }
        .toast { background-color: var(--color-surface); color: var(--color-on-surface); padding: 1rem 1.5rem; border-radius: var(--border-radius-medium); box-shadow: var(--elevation-3); display: flex; align-items: center; gap: 1rem; transform: translateX(120%); opacity: 0; transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.4s; border-left: 5px solid; }
        .toast.show { transform: translateX(0); opacity: 1; }
        .toast.success { border-color: var(--color-success); } .toast.success .material-icons-outlined { color: var(--color-success); }
        .toast.error { border-color: var(--color-error); } .toast.error .material-icons-outlined { color: var(--color-error); }
        .toast.info { border-color: var(--color-primary); } .toast.info .material-icons-outlined { color: var(--color-primary); }
        
        .wizard-status-bar { background-color: color-mix(in srgb, var(--color-primary) 10%, transparent); border-radius: var(--border-radius-medium); padding: 0.75rem 1.25rem; }
        .status-item { display: flex; align-items: center; gap: 0.5rem; color: var(--color-primary); font-weight: 500; }
        
        .modal-backdrop { position: fixed; inset: 0; background-color: rgba(0,0,0,0.5); backdrop-filter: blur(2px); z-index: 1040; display: none; align-items: center; justify-content: center; padding: 1rem; animation: fadeInModal 0.2s ease; }
        .modal-backdrop.visible { display: flex; }
        @keyframes fadeInModal { from { opacity: 0; } to { opacity: 1; } }
        .modal-content { background-color: var(--color-surface); color: var(--color-on-surface); padding: 1.75rem; border-radius: var(--border-radius-large); box-shadow: var(--elevation-3); min-width: 320px; max-width: 95%; width: 560px; transform: scale(0.95); animation: scaleInModal 0.2s ease forwards; }
        @keyframes scaleInModal { from { transform: scale(0.95); } to { transform: scale(1); } }
        
        .stored-key-item { display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; border-radius: var(--border-radius-medium); transition: background-color 0.2s; cursor: pointer; }
        .stored-key-item:hover { background-color: color-mix(in srgb, var(--color-primary) 15%, transparent); }
        .stored-key-name { font-weight: 500; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; padding-right: 1rem; flex-grow: 1;}
        .progress-bar { width: 100%; background-color: var(--color-outline); border-radius: var(--border-radius-full); height: 4px; overflow: hidden; margin-top: 4px; }
        .progress-bar-inner { width: 0%; height: 100%; background-color: var(--color-primary); transition: width 0.1s linear; }
        #sound-visualizer { width: 100%; height: 80px; display: block; background-color: rgba(0,0,0,0.05); border-radius: 8px; }
        #qr-video { width: 100%; border-radius: 8px; }
    </style>
</head>
<body>
    <canvas id="background-canvas"></canvas>
    <main class="container mx-auto p-4 md:p-8 relative z-10">
        <header class="app-header text-center mb-10">
            <div class="flex items-center justify-center gap-4">
                <img src="https://quixoticode.github.io/data/qsounds/favicon.svg" class="w-12 h-12" alt="QSounds Logo">
                <h1 class="text-4xl md:text-5xl font-bold bg-gradient-to-r from-purple-600 to-teal-500 dark:from-purple-400 dark:to-teal-300 text-transparent bg-clip-text">QSounds</h1>
            </div>
            <p class="text-lg mt-2" style="color: var(--color-on-surface-variant);">Der einfache Assistent für RSA-Verschlüsselung. Version 1.6 Ultimate Cyberspace.</p>
            <div class="absolute top-4 right-4">
                <button id="theme-toggle" class="qs-button-text p-2 rounded-full">
                    <span class="material-icons-outlined"></span>
                </button>
            </div>
        </header>

        <!-- STEP 0: Initial Choice -->
        <div id="step-initial-choice" class="wizard-step active">
            <div class="card max-w-4xl mx-auto">
                <h2 class="text-2xl font-bold text-center mb-6" style="color: var(--color-primary);">Was möchtest du tun?</h2>
                <div class="grid md:grid-cols-3 gap-6">
                    <div id="choice-encrypt" class="choice-button">
                        <span class="material-icons-outlined">lock</span>
                        <p class="text-xl font-bold mt-2">Verschlüsseln</p>
                        <p class="text-sm mt-1" style="color: var(--color-on-surface-variant);">Eine Nachricht sicher machen</p>
                    </div>
                    <div id="choice-decrypt" class="choice-button">
                        <span class="material-icons-outlined">lock_open</span>
                        <p class="text-xl font-bold mt-2">Entschlüsseln</p>
                        <p class="text-sm mt-1" style="color: var(--color-on-surface-variant);">Eine Nachricht lesbar machen</p>
                    </div>
                    <div id="choice-manage-keys" class="choice-button">
                        <span class="material-icons-outlined">vpn_key</span>
                        <p class="text-xl font-bold mt-2">Schlüssel verwalten</p>
                        <p class="text-sm mt-1" style="color: var(--color-on-surface-variant);">Erstellen, importieren, löschen</p>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- STEP 1: Key Management -->
        <div id="step-key-management" class="wizard-step">
            <div class="card max-w-4xl mx-auto">
                <div class="flex flex-wrap justify-between items-center mb-6 gap-4">
                     <h2 class="text-2xl font-bold" style="color: var(--color-primary);">Schlüsselverwaltung</h2>
                     <button id="btn-back-to-start-1" class="qs-button-text">Zurück zum Start</button>
                 </div>
                 <div class="flex flex-wrap gap-4 mb-6">
                     <button id="btn-generate-new-key" class="qs-button">Neuen Schlüssel generieren</button>
                     <button id="btn-import-key-file" class="qs-button secondary">Aus Datei importieren</button>
                 </div>
                 <div id="key-management-list-container" class="space-y-2">
                 </div>
            </div>
        </div>

        <!-- STEP 2: Main Interface (Wizard) -->
        <div id="step-main-interface" class="wizard-step">
            <div class="card max-w-4xl mx-auto">
                <div class="wizard-status-bar mb-6">
                    <div class="flex flex-wrap items-center justify-between gap-4">
                        <div class="flex flex-wrap gap-x-6 gap-y-2">
                            <div class="status-item"><span class="material-icons-outlined text-xl">label</span>Aktion: <span id="status-action" class="font-normal opacity-80"></span></div>
                            <div class="status-item"><span class="material-icons-outlined text-xl">key</span>Schlüssel: <span id="status-key" class="font-normal opacity-80"></span></div>
                            <div class="status-item"><span class="material-icons-outlined text-xl">feed</span>Eingabe: <span id="status-input" class="font-normal opacity-80"></span></div>
                        </div>
                        <button id="btn-start-over" class="qs-button-text">Von vorne beginnen</button>
                    </div>
                </div>
                <div class="grid md:grid-cols-2 gap-8">
                    <div class="space-y-6">
                        <div id="area-key-source">
                            <h3 class="text-xl font-bold mb-4" id="key-source-title"></h3>
                            <div class="grid grid-cols-2 gap-3" id="key-source-choices"></div>
                            <div id="key-manual-input-area" class="hidden mt-4 space-y-4">
                                <textarea id="manual-public-key" class="qs-textarea font-mono text-xs" rows="6" placeholder="Öffentlichen Schlüssel hier einfügen... (PEM-Format)"></textarea>
                                <textarea id="manual-private-key" class="qs-textarea font-mono text-xs" rows="6" placeholder="Privaten Schlüssel hier einfügen... (PEM-Format)"></textarea>
                            </div>
                        </div>
                        <div id="area-input-method" class="hidden">
                            <h3 class="text-xl font-bold mb-4">Wie möchtest du deine Nachricht eingeben?</h3>
                            <div class="grid grid-cols-2 gap-3">
                                 <button id="choice-input-text" class="choice-button !p-6"><span class="material-icons-outlined !text-4xl">edit_document</span><p class="font-bold mt-1">Als Text</p></button>
                                 <button id="choice-input-sound" class="choice-button !p-6"><span class="material-icons-outlined !text-4xl">graphic_eq</span><p class="font-bold mt-1">Per Ton</p></button>
                            </div>
                        </div>
                    </div>
                    <div id="area-data-action" class="space-y-6 hidden">
                         <div>
                            <label id="data-input-label" for="data-input-textarea" class="text-xl font-bold mb-4 block"></label>
                            <textarea id="data-input-textarea" class="qs-textarea" rows="8"></textarea>
                         </div>
                         <button id="btn-process" class="qs-button w-full text-lg !py-4"></button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- STEP 3: Output -->
        <div id="step-output" class="wizard-step">
            <div class="card max-w-4xl mx-auto">
                 <div class="flex justify-between items-center mb-6">
                     <h2 class="text-2xl font-bold" style="color: var(--color-primary);">Ergebnis</h2>
                     <button id="btn-start-over-output" class="qs-button-text">Neue Aktion starten</button>
                 </div>
                 <textarea id="output-textarea" readonly class="qs-textarea font-mono text-sm" rows="10"></textarea>
                 <div class="flex items-center flex-wrap gap-4 mt-4">
                     <button onclick="copyToClipboard('output-textarea', 'Ergebnis')" class="qs-button">Kopieren</button>
                     <button id="btn-play-output" class="qs-button flex items-center gap-1">
                        <span class="material-icons-outlined text-base">volume_up</span><span class="button-text">Abspielen</span>
                    </button>
                    <div class="progress-bar flex-grow"><div id="progressOutput" class="progress-bar-inner"></div></div>
                 </div>
            </div>
        </div>

    </main>
    
    <div id="toast-container"></div>
    <div id="modal-container"></div>


    <script>
        // QSounds v1.6 Ultimate Cyberspace Update
        
        // --- DOM Element Cache & Wizard State ---
        const getEl = (id) => document.getElementById(id);
        const DOMElements = {
            steps: {
                initial: getEl('step-initial-choice'),
                manageKeys: getEl('step-key-management'),
                main: getEl('step-main-interface'),
                output: getEl('step-output'),
            },
            choices: {
                encrypt: getEl('choice-encrypt'),
                decrypt: getEl('choice-decrypt'),
                manageKeys: getEl('choice-manage-keys'),
                inputText: getEl('choice-input-text'),
                inputSound: getEl('choice-input-sound'),
            },
            manageKeys: {
                listContainer: getEl('key-management-list-container'),
                btnGenerateNew: getEl('btn-generate-new-key'),
                btnImport: getEl('btn-import-key-file'),
                btnBack: getEl('btn-back-to-start-1'),
            },
            main: {
                statusAction: getEl('status-action'),
                statusKey: getEl('status-key'),
                statusInput: getEl('status-input'),
                keySourceArea: getEl('area-key-source'),
                keySourceTitle: getEl('key-source-title'),
                keySourceChoices: getEl('key-source-choices'),
                keyManualInputArea: getEl('key-manual-input-area'),
                manualPublicKey: getEl('manual-public-key'),
                manualPrivateKey: getEl('manual-private-key'),
                inputMethodArea: getEl('area-input-method'),
                dataActionArea: getEl('area-data-action'),
                dataInputLabel: getEl('data-input-label'),
                dataInputTextarea: getEl('data-input-textarea'),
                btnProcess: getEl('btn-process'),
            },
            output: {
                textarea: getEl('output-textarea'),
                btnPlay: getEl('btn-play-output'),
                progress: getEl('progressOutput'),
            },
            buttons: {
                startOver: getEl('btn-start-over'),
                startOverOutput: getEl('btn-start-over-output'),
                themeToggle: getEl('theme-toggle'),
            },
            modalContainer: getEl('modal-container'),
            toastContainer: getEl('toast-container'),
            backgroundCanvas: getEl('background-canvas'),
        };

        let wizardState = {};
        const initialWizardState = {
            action: null, keySource: null, inputMethod: null,
            publicKey: null, privateKey: null, keyName: null, data: null,
        };

        const STORAGE_KEYS = { 
            STORED_KEYS: `QSounds_v1_6_Ultimate_storedKeys`,
            THEME: 'QSounds_v1_6_theme'
        };
        let audioState = { context: null, masterGain: null, isPlaying: false, microphoneStream: null, isListening: false, animationFrameId: null, playbackTimeoutId: null };
        let backgroundAnimationId = null;

        // --- Wizard Navigation & UI ---
        function navigateToStep(stepId) {
            Object.values(DOMElements.steps).forEach(step => step.classList.remove('active'));
            getEl(stepId).classList.add('active');
        }
        
        function resetWizard() {
            wizardState = { ...initialWizardState };
            navigateToStep('step-initial-choice');
        }

        function updateMainInterface() {
            const { main } = DOMElements;
            main.statusAction.textContent = wizardState.action === 'encrypt' ? 'Verschlüsseln' : (wizardState.action ? 'Entschlüsseln' : '...');
            main.statusKey.textContent = '...';
            main.statusInput.textContent = '...';

            main.keySourceArea.classList.add('hidden');
            main.keyManualInputArea.classList.add('hidden');
            main.inputMethodArea.classList.add('hidden');
            main.dataActionArea.classList.add('hidden');

            if (!wizardState.keySource) {
                main.keySourceArea.classList.remove('hidden');
                renderKeySourceChoices();
            } else {
                main.statusKey.textContent = {
                    'new': 'Neu generiert',
                    'saved': `Gespeichert (${wizardState.keyName || '...'})`,
                    'manual': 'Manuell eingefügt',
                    'import': 'Importiert',
                    'qr': 'Per QR-Code gescannt'
                }[wizardState.keySource];

                if (wizardState.keySource === 'manual' && !wizardState.keyName) {
                    main.keyManualInputArea.classList.remove('hidden');
                } else if (!wizardState.inputMethod) {
                    main.inputMethodArea.classList.remove('hidden');
                } else {
                    main.statusInput.textContent = wizardState.inputMethod === 'text' ? 'Text' : 'Ton';
                    main.dataActionArea.classList.remove('hidden');
                    main.dataInputLabel.textContent = wizardState.action === 'encrypt' ? 'Zu verschlüsselnder Text:' : 'Zu entschlüsselnder Chiffretext:';
                    main.btnProcess.textContent = wizardState.action === 'encrypt' ? 'Jetzt verschlüsseln' : 'Jetzt entschlüsseln';
                }
            }
        }
        
        function renderKeySourceChoices() {
            const { keySourceChoices, keySourceTitle } = DOMElements.main;
            keySourceChoices.innerHTML = '';
            const createChoice = (id, icon, text) => {
                const choice = document.createElement('button');
                choice.id = `choice-key-${id}`;
                choice.className = 'choice-button !p-6';
                choice.innerHTML = `<span class="material-icons-outlined !text-4xl">${icon}</span><p class="font-bold mt-1">${text}</p>`;
                choice.addEventListener('click', () => handleKeySourceSelection(id));
                return choice;
            };
            
            keySourceChoices.classList.remove('md:grid-cols-3', 'lg:grid-cols-4');
            keySourceChoices.classList.add('md:grid-cols-2');

            if (wizardState.action === 'encrypt') {
                keySourceTitle.textContent = 'Welchen öffentlichen Schlüssel verwenden?';
                keySourceChoices.classList.add('lg:grid-cols-4');
                keySourceChoices.appendChild(createChoice('new', 'add_circle_outline', 'Neuen erstellen'));
                keySourceChoices.appendChild(createChoice('saved', 'inventory_2', 'Gespeicherten laden'));
                keySourceChoices.appendChild(createChoice('manual', 'keyboard', 'Manuell einfügen'));
                keySourceChoices.appendChild(createChoice('qr', 'qr_code_scanner', 'QR-Code scannen'));
            } else {
                keySourceTitle.textContent = 'Welchen privaten Schlüssel verwenden?';
                keySourceChoices.appendChild(createChoice('saved', 'inventory_2', 'Gespeicherten laden'));
                keySourceChoices.appendChild(createChoice('manual', 'keyboard', 'Manuell einfügen'));
            }
        }
        
        async function handleKeySourceSelection(source) {
            wizardState.keySource = source;
            const { keyManualInputArea, manualPublicKey, manualPrivateKey } = DOMElements.main;
            
            switch(source) {
                case 'new':
                    await generateRSAKeyPair({ autoContinue: true });
                    break;
                case 'saved':
                    showStoredKeysModal();
                    break;
                case 'qr':
                    showQrScannerModal();
                    break;
                case 'manual':
                    manualPublicKey.style.display = wizardState.action === 'encrypt' ? 'block' : 'none';
                    manualPrivateKey.style.display = wizardState.action === 'decrypt' ? 'block' : 'none';
                    manualPublicKey.value = '';
                    manualPrivateKey.value = '';
                    
                    const btn = document.createElement('button');
                    btn.textContent = 'Schlüssel verwenden';
                    btn.className = 'qs-button mt-2';
                    btn.onclick = () => {
                        const pubKey = manualPublicKey.value.trim();
                        const privKey = manualPrivateKey.value.trim();
                        if ((wizardState.action === 'encrypt' && !pubKey) || (wizardState.action === 'decrypt' && !privKey)) {
                            showToast('error', 'Bitte geben Sie den erforderlichen Schlüssel ein.'); return;
                        }
                        wizardState.publicKey = pubKey;
                        wizardState.privateKey = privKey;
                        wizardState.keyName = 'Manuell';
                        updateMainInterface();
                    };
                    keyManualInputArea.querySelector('button')?.remove();
                    keyManualInputArea.appendChild(btn);
                    updateMainInterface();
                    break;
            }
        }

        function renderKeyManagementView() {
            const keys = getStoredKeys();
            const { listContainer } = DOMElements.manageKeys;
            listContainer.innerHTML = '';
            if (keys.length === 0) {
                listContainer.innerHTML = '<p class="text-center p-4" style="color: var(--color-on-surface-variant);">Keine Schlüssel gespeichert. Erstelle einen neuen oder importiere eine Datei.</p>';
                return;
            }
            keys.forEach(key => {
                const item = document.createElement('div');
                item.className = 'stored-key-item !cursor-default border border-transparent hover:bg-black/5 dark:hover:bg-white/5';
                item.innerHTML = `
                    <span class="stored-key-name flex items-center gap-2"><span class="material-icons-outlined text-gray-400">key</span>${key.name}</span>
                    <div class="flex items-center gap-2">
                        <button class="qs-button-text text-sm" data-action="export" data-key-name="${key.name}">Exportieren</button>
                        <button class="qs-button-text text-sm" data-action="qr" data-key-name="${key.name}">QR-Code</button>
                        <button class="qs-button-text !text-red-500 text-sm" data-action="delete" data-key-name="${key.name}">Löschen</button>
                    </div>
                `;
                listContainer.appendChild(item);
            });
            listContainer.addEventListener('click', async (e) => {
                const target = e.target.closest('button');
                if (!target) return;
                const action = target.dataset.action;
                const keyName = target.dataset.keyName;
                const key = getStoredKeys().find(k => k.name === keyName);
                if (!key) return;

                switch(action) {
                    case 'export': exportKeyPair(key); break;
                    case 'qr': showQRCode(key); break;
                    case 'delete': 
                        const confirmed = await customConfirm({
                            title: 'Löschen bestätigen',
                            message: `Möchtest du das Schlüsselpaar "${keyName}" wirklich endgültig löschen?`,
                            confirmText: 'Löschen'
                        });
                        if (confirmed) {
                            deleteKeyPair(keyName);
                        }
                        break;
                }
            });
        }
        
        // --- Core Logic ---
        function processData() {
            wizardState.data = DOMElements.main.dataInputTextarea.value.trim();
            if (!wizardState.data) { showToast('error', 'Keine Daten zur Verarbeitung eingegeben.'); return; }
            let result = null;
            try {
                if (wizardState.action === 'encrypt') {
                    if (!wizardState.publicKey) { showToast('error', 'Kein öffentlicher Schlüssel zum Verschlüsseln vorhanden.'); return; }
                    const encryptor = new JSEncrypt(); 
                    encryptor.setPublicKey(wizardState.publicKey);
                    result = encryptor.encrypt(wizardState.data);
                    if (result === false) throw new Error("Verschlüsselung fehlgeschlagen. Der Schlüssel ist möglicherweise ungültig oder die Daten sind zu lang.");
                } else {
                    if (!wizardState.privateKey) { showToast('error', 'Kein privater Schlüssel zum Entschlüsseln vorhanden.'); return; }
                    const decryptor = new JSEncrypt(); 
                    decryptor.setPrivateKey(wizardState.privateKey);
                    result = decryptor.decrypt(wizardState.data);
                    if (result === false) throw new Error("Entschlüsselung fehlgeschlagen. Der Schlüssel ist ungültig oder der Chiffretext ist korrupt.");
                }
                DOMElements.output.textarea.value = result;
                navigateToStep('step-output');
            } catch (e) { 
                showToast('error', e.message); 
                console.error(e);
            }
        }

        async function generateRSAKeyPair({ autoContinue = false } = {}) {
            const name = await customPrompt({title: 'Neuer Schlüssel', message: 'Wie soll dieses Schlüsselpaar heißen?', initialValue: `Schlüssel vom ${new Date().toLocaleDateString()}`});
            if (!name) {
                showToast('info', 'Erstellung abgebrochen.');
                if (autoContinue) { wizardState.keySource = null; updateMainInterface(); }
                return;
            }
            if (getStoredKeys().some(k => k.name === name)) {
                showToast('error', 'Ein Schlüssel mit diesem Namen existiert bereits.');
                if (autoContinue) { wizardState.keySource = null; updateMainInterface(); }
                return;
            }
            const toastId = showToast('info', 'Generiere 2048-bit Schlüsselpaar... Das kann einen Moment dauern.', 10000);
            
            await new Promise(resolve => {
                const crypt = new JSEncrypt({ default_key_size: 2048 });
                crypt.getKey(() => {
                    const keyPair = { name, publicKey: crypt.getPublicKey(), privateKey: crypt.getPrivateKey() };
                    const keys = getStoredKeys();
                    keys.push(keyPair);
                    saveStoredKeys(keys);
                    hideToast(toastId);
                    showToast('success', `Schlüsselpaar "${name}" erstellt und gespeichert!`);
                    if(autoContinue) {
                        wizardState = {...wizardState, ...keyPair, keyName: name };
                        updateMainInterface();
                    } else {
                        renderKeyManagementView();
                    }
                    resolve();
                });
            });
        }
        
        // --- Event Listeners ---
        function initializeListeners() {
            DOMElements.choices.encrypt.addEventListener('click', () => { wizardState.action = 'encrypt'; navigateToStep('step-main-interface'); updateMainInterface(); });
            DOMElements.choices.decrypt.addEventListener('click', () => { wizardState.action = 'decrypt'; navigateToStep('step-main-interface'); updateMainInterface(); });
            DOMElements.choices.manageKeys.addEventListener('click', () => { navigateToStep('step-key-management'); renderKeyManagementView(); });
            
            DOMElements.choices.inputText.addEventListener('click', () => { wizardState.inputMethod = 'text'; updateMainInterface(); });
            DOMElements.choices.inputSound.addEventListener('click', () => showSoundListenerModal());
            
            DOMElements.manageKeys.btnBack.addEventListener('click', resetWizard);
            DOMElements.manageKeys.btnGenerateNew.addEventListener('click', () => generateRSAKeyPair({ autoContinue: false }));
            DOMElements.manageKeys.btnImport.addEventListener('click', () => importKeyPairFile());
            
            DOMElements.buttons.startOver.addEventListener('click', resetWizard);
            DOMElements.buttons.startOverOutput.addEventListener('click', resetWizard);
            DOMElements.main.btnProcess.addEventListener('click', processData);
            DOMElements.output.btnPlay.addEventListener('click', () => playTextAsSound(DOMElements.output.textarea.value, DOMElements.output.btnPlay, DOMElements.output.progress));
            
            DOMElements.buttons.themeToggle.addEventListener('click', toggleTheme);
        }
        
        // --- Modals & Helper Functions ---
        function createModal(innerHTML, onOpen = () => {}, isCancellable = true) {
            const modalId = `modal-${Date.now()}`;
            const modalHTML = `<div id="${modalId}" class="modal-backdrop">
                <div class="modal-content" onclick="event.stopPropagation()">${innerHTML}</div>
            </div>`;
            DOMElements.modalContainer.innerHTML = modalHTML;
            const modal = getEl(modalId);
            modal.classList.add('visible');
            
            const cleanupAndClose = () => {
                const video = modal.querySelector('video');
                if (video && video.srcObject) {
                    video.srcObject.getTracks().forEach(track => track.stop());
                }
                closeModal();
            };

            if (isCancellable) {
                modal.addEventListener('click', cleanupAndClose);
            }
            
            onOpen(modal);
        }

        function closeModal() { 
            const modal = DOMElements.modalContainer.querySelector('.modal-backdrop');
            if(modal) {
                const video = modal.querySelector('video');
                if (video && video.srcObject) {
                    video.srcObject.getTracks().forEach(track => track.stop());
                }
            }
            DOMElements.modalContainer.innerHTML = ''; 
            if (audioState.isListening) stopListening(); 
        }
        
        function showToast(type, message, duration = 4000) {
            const id = `toast-${Date.now()}`;
            const toast = document.createElement('div');
            toast.id = id;
            toast.className = `toast ${type}`;
            toast.innerHTML = `<span class="material-icons-outlined">${{success: 'check_circle', error: 'error', info: 'info'}[type]}</span><span>${message}</span>`;
            DOMElements.toastContainer.appendChild(toast);
            setTimeout(() => toast.classList.add('show'), 50);
            if (duration > 0) {
                setTimeout(() => hideToast(id), duration);
            }
            return id;
        }

        function hideToast(id) {
            const toast = getEl(id);
            if (toast) {
                toast.classList.remove('show');
                toast.addEventListener('transitionend', () => toast.remove());
            }
        }
        
        function getStoredKeys() { return JSON.parse(localStorage.getItem(STORAGE_KEYS.STORED_KEYS) || '[]'); }
        
        function saveStoredKeys(keys) { 
            localStorage.setItem(STORAGE_KEYS.STORED_KEYS, JSON.stringify(keys)); 
            if(getEl('step-key-management').classList.contains('active')) {
                renderKeyManagementView();
            }
        }

        function deleteKeyPair(name) { 
            let keys = getStoredKeys(); 
            keys = keys.filter(k => k.name !== name); 
            saveStoredKeys(keys); 
            showToast('success', `Schlüssel "${name}" gelöscht.`); 
        }
        
        function importKeyPairFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = async e => {
                const file = e.target.files[0];
                if (!file) return;
                try {
                    const content = await file.text();
                    const keyPair = JSON.parse(content);
                    if (!keyPair.name || !keyPair.publicKey || !keyPair.privateKey) {
                        throw new Error('Ungültiges Dateiformat.');
                    }
                    if (getStoredKeys().some(k => k.name === keyPair.name)) {
                        showToast('error', `Ein Schlüssel mit dem Namen "${keyPair.name}" existiert bereits.`);
                        return;
                    }
                    const keys = getStoredKeys();
                    keys.push(keyPair);
                    saveStoredKeys(keys);
                    showToast('success', `Schlüssel "${keyPair.name}" erfolgreich importiert.`);
                } catch (err) {
                    showToast('error', `Import fehlgeschlagen: ${err.message}`);
                }
            };
            input.click();
        }

        function exportKeyPair(key) {
            const blob = new Blob([JSON.stringify(key, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${key.name.replace(/\s/g, '_')}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showToast('success', 'Schlüssel wird exportiert.');
        }

        function showQRCode(key) {
            const content = `
                <h2 class="text-xl font-bold mb-4">QR-Code für "${key.name}"</h2>
                <p class="text-sm mb-1" style="color: var(--color-on-surface-variant);">Öffentlicher Schlüssel:</p>
                <div id="qr-code-public" class="flex justify-center mb-4 p-2 bg-white rounded-lg"></div>
                <div class="flex justify-end gap-3 mt-6">
                    <button class="qs-button-text" onclick="closeModal()">Schließen</button>
                </div>
            `;
            createModal(content, () => {
                new QRCode(getEl('qr-code-public'), {
                    text: key.publicKey,
                    width: 256,
                    height: 256,
                    correctLevel: QRCode.CorrectLevel.M
                });
            });
        }

        async function customPrompt({title, message, initialValue = ''}) {
            return new Promise(resolve => {
                const content = `
                    <h2 class="text-xl font-bold mb-4">${title}</h2>
                    <p class="mb-4" style="color: var(--color-on-surface-variant);">${message}</p>
                    <input id="prompt-input" type="text" class="qs-textarea w-full" value="${initialValue}">
                    <div class="flex justify-end gap-3 mt-6">
                        <button id="prompt-cancel" class="qs-button-text">Abbrechen</button>
                        <button id="prompt-ok" class="qs-button">OK</button>
                    </div>
                `;
                createModal(content, modal => {
                    const input = modal.querySelector('#prompt-input');
                    input.focus();
                    input.select();
                    modal.querySelector('#prompt-ok').onclick = () => { closeModal(); resolve(input.value); };
                    modal.querySelector('#prompt-cancel').onclick = () => { closeModal(); resolve(null); };
                    input.onkeydown = (e) => { if (e.key === 'Enter') modal.querySelector('#prompt-ok').click(); };
                }, false);
            });
        }
        
        async function customConfirm({ title, message, confirmText = 'OK', cancelText = 'Abbrechen' }) {
            return new Promise(resolve => {
                const content = `
                    <h2 class="text-xl font-bold mb-4">${title}</h2>
                    <p class="mb-6" style="color: var(--color-on-surface-variant);">${message}</p>
                    <div class="flex justify-end gap-3">
                        <button id="confirm-cancel" class="qs-button-text">${cancelText}</button>
                        <button id="confirm-ok" class="qs-button !bg-red-600 hover:!bg-red-700">${confirmText}</button>
                    </div>
                `;
                createModal(content, modal => {
                    modal.querySelector('#confirm-ok').onclick = () => { closeModal(); resolve(true); };
                    modal.querySelector('#confirm-cancel').onclick = () => { closeModal(); resolve(false); };
                }, false);
            });
        }

        function copyToClipboard(elementId, type) {
            const textarea = getEl(elementId);
            textarea.select();
            document.execCommand('copy');
            showToast('success', `${type} in die Zwischenablage kopiert.`);
        }

        function showStoredKeysModal() {
            const keys = getStoredKeys();
            if (keys.length === 0) { 
                showToast('error', 'Keine Schlüssel gespeichert. Erstelle zuerst einen.'); 
                wizardState.keySource = null; 
                updateMainInterface(); 
                return; 
            }
            let content = `<h2 class="text-xl font-bold mb-4">Gespeicherten Schlüssel laden</h2><div class="space-y-2 max-h-60 overflow-y-auto">`;
            keys.forEach(key => { content += `<div class="stored-key-item" data-key-name="${key.name}"><span class="stored-key-name">${key.name}</span></div>`; });
            content += `</div>`;
            createModal(content, (modal) => {
                modal.querySelectorAll('.stored-key-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const key = keys.find(k => k.name === item.dataset.keyName);
                        wizardState.publicKey = key.publicKey;
                        wizardState.privateKey = key.privateKey;
                        wizardState.keyName = key.name;
                        wizardState.keySource = 'saved';
                        closeModal();
                        updateMainInterface();
                    });
                });
            }, true);
        }

        // --- QR Code Scanner ---
        function showQrScannerModal() {
            let stream = null;
            let animationFrameId = null;

            const content = `
                <h2 class="text-xl font-bold mb-4">QR-Code scannen</h2>
                <p id="qr-status" class="text-center mb-2" style="color: var(--color-on-surface-variant);">Kamera wird gestartet...</p>
                <video id="qr-video" playsinline></video>
                <canvas id="qr-canvas" class="hidden"></canvas>
                <div class="flex justify-end gap-3 mt-6">
                    <button id="qr-cancel" class="qs-button-text">Abbrechen</button>
                </div>
            `;

            const cleanup = () => {
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }
                closeModal();
            };

            createModal(content, modal => {
                const video = modal.querySelector('#qr-video');
                const canvasEl = modal.querySelector('#qr-canvas');
                const statusEl = modal.querySelector('#qr-status');
                const canvas = canvasEl.getContext('2d');
                
                modal.querySelector('#qr-cancel').onclick = cleanup;

                navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
                    .then(s => {
                        stream = s;
                        video.srcObject = stream;
                        video.setAttribute("playsinline", true);
                        video.play();
                        statusEl.textContent = 'Richte die Kamera auf einen QR-Code.';
                        animationFrameId = requestAnimationFrame(tick);
                    })
                    .catch(err => {
                        console.error("QR Scanner Error:", err);
                        statusEl.textContent = 'Kamerazugriff fehlgeschlagen.';
                        showToast('error', 'Konnte nicht auf die Kamera zugreifen.');
                    });

                function tick() {
                    if (video.readyState === video.HAVE_ENOUGH_DATA) {
                        canvasEl.height = video.videoHeight;
                        canvasEl.width = video.videoWidth;
                        canvas.drawImage(video, 0, 0, canvasEl.width, canvasEl.height);
                        const imageData = canvas.getImageData(0, 0, canvasEl.width, canvasEl.height);
                        const code = jsQR(imageData.data, imageData.width, imageData.height, {
                            inversionAttempts: "dontInvert",
                        });

                        if (code) {
                            statusEl.textContent = 'Code gefunden!';
                            showToast('success', 'QR-Code erfolgreich gescannt!');
                            wizardState.keySource = 'qr';
                            wizardState.publicKey = code.data;
                            wizardState.keyName = 'Gescannter Schlüssel';
                            updateMainInterface();
                            cleanup();
                            return;
                        }
                    }
                    animationFrameId = requestAnimationFrame(tick);
                }
            }, false);
        }

        // --- Audio Functions ---
        const CHAR_TO_FREQ_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        const BASE_FREQ = 300, FREQ_STEP = 30, NOTE_DURATION = 0.07, PAUSE_DURATION = 0.035;
        
        function getAudioContext() {
            if (!audioState.context || audioState.context.state === 'closed') {
                try {
                    audioState.context = new (window.AudioContext || window.webkitAudioContext)();
                    audioState.masterGain = audioState.context.createGain();
                    audioState.masterGain.connect(audioState.context.destination);
                } catch(e) {
                    showToast('error', 'Web Audio API wird nicht unterstützt.');
                    return null;
                }
            }
            if (audioState.context.state === 'suspended') {
                audioState.context.resume();
            }
            return audioState.context;
        }

        function playTextAsSound(text, playButton, progressBar) {
            const context = getAudioContext();
            if (!context) return;
            if (audioState.isPlaying) { 
                stopSound(playButton, progressBar); 
                return; 
            }

            audioState.isPlaying = true;
            updatePlayButton(playButton, true);
            audioState.masterGain.gain.setValueAtTime(1, context.currentTime);
            let currentTime = context.currentTime;

            for (let i = 0; i < text.length; i++) {
                const charIndex = CHAR_TO_FREQ_MAP.indexOf(text[i]);
                if (charIndex !== -1) {
                    const freq = BASE_FREQ + charIndex * FREQ_STEP;
                    const oscillator = context.createOscillator();
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(freq, currentTime);
                    oscillator.connect(audioState.masterGain);
                    oscillator.start(currentTime);
                    oscillator.stop(currentTime + NOTE_DURATION);
                }
                currentTime += NOTE_DURATION + PAUSE_DURATION;
            }

            const totalDuration = text.length * (NOTE_DURATION + PAUSE_DURATION);
            const interval = setInterval(() => {
                if(!audioState.isPlaying) {
                    clearInterval(interval);
                    return;
                }
                const elapsed = context.currentTime - (currentTime - totalDuration);
                const progress = Math.min(100, (elapsed / totalDuration) * 100);
                progressBar.style.width = `${progress}%`;
            }, 50);

            audioState.playbackTimeoutId = setTimeout(() => {
                clearInterval(interval);
                if(audioState.isPlaying) stopSound(playButton, progressBar);
            }, totalDuration * 1000 + 100);
        }

        function stopSound(playButton, progressBar) {
            if (audioState.playbackTimeoutId) clearTimeout(audioState.playbackTimeoutId);
            
            if (audioState.context && audioState.masterGain) {
                audioState.masterGain.gain.cancelScheduledValues(audioState.context.currentTime);
                audioState.masterGain.gain.linearRampToValueAtTime(0, audioState.context.currentTime + 0.01);
            }

            audioState.isPlaying = false;
            updatePlayButton(playButton, false);
            if(progressBar) progressBar.style.width = '0%';
        }
        
        function updatePlayButton(button, isPlaying) {
            const icon = button.querySelector('.material-icons-outlined');
            const text = button.querySelector('.button-text');
            if (isPlaying) {
                icon.textContent = 'stop';
                text.textContent = 'Stopp';
            } else {
                icon.textContent = 'volume_up';
                text.textContent = 'Abspielen';
            }
        }
        
        function showSoundListenerModal() {
            const content = `
                <h2 class="text-xl font-bold mb-4">Tonerkennung</h2>
                <p id="sound-listener-status" class="text-center mb-4" style="color: var(--color-on-surface-variant);">Bereit. Klicke auf "Start", um die Aufnahme zu beginnen.</p>
                <canvas id="sound-visualizer"></canvas>
                <div class="mt-4 p-4 rounded-lg bg-black/10 dark:bg-white/10 min-h-[6rem] font-mono text-sm break-all" id="sound-listener-result"></div>
                <div class="flex justify-between items-center mt-6">
                    <button id="sound-listener-start" class="qs-button">Start</button>
                    <div class="flex gap-2">
                        <button id="sound-listener-accept" class="qs-button secondary" disabled>Übernehmen</button>
                        <button class="qs-button-text" onclick="closeModal()">Abbrechen</button>
                    </div>
                </div>`;
            createModal(content, (modal) => {
                const startBtn = modal.querySelector('#sound-listener-start');
                const acceptBtn = modal.querySelector('#sound-listener-accept');
                const resultEl = modal.querySelector('#sound-listener-result');
                startBtn.onclick = () => { 
                    if (audioState.isListening) stopListening(modal);
                    else startListening(modal); 
                };
                acceptBtn.onclick = () => {
                    DOMElements.main.dataInputTextarea.value = resultEl.textContent;
                    wizardState.inputMethod = 'text';
                    updateMainInterface();
                    closeModal();
                };
            }, false);
        }

        async function startListening(modal) {
            if (audioState.isListening) return;
            const context = getAudioContext();
            if (!context) { showToast('error', 'Audio-Kontext konnte nicht initialisiert werden.'); return; }
            
            const statusEl = modal.querySelector('#sound-listener-status');
            const acceptBtn = modal.querySelector('#sound-listener-accept');
            const startBtn = modal.querySelector('#sound-listener-start');
            
            try {
                audioState.microphoneStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                audioState.isListening = true;
                statusEl.textContent = 'Höre zu...';
                startBtn.textContent = 'Stop';
                acceptBtn.disabled = false;
                
                const source = context.createMediaStreamSource(audioState.microphoneStream);
                const analyser = context.createAnalyser();
                analyser.fftSize = 4096;
                analyser.smoothingTimeConstant = 0.6;
                source.connect(analyser);
                audioState.analyser = analyser;
                analyzeSound(modal);
            } catch (err) {
                statusEl.textContent = 'Mikrofon-Zugriff fehlgeschlagen oder verweigert.';
                console.error("Mikrofon-Fehler:", err);
            }
        }

        function stopListening(modal) {
            if (audioState.microphoneStream) {
                audioState.microphoneStream.getTracks().forEach(track => track.stop());
            }
            if (audioState.animationFrameId) {
                cancelAnimationFrame(audioState.animationFrameId);
                audioState.animationFrameId = null;
            }
            audioState.isListening = false;
            audioState.microphoneStream = null;
            audioState.analyser = null;

            if (modal) {
                modal.querySelector('#sound-listener-status').textContent = 'Aufnahme gestoppt.';
                modal.querySelector('#sound-listener-start').textContent = 'Start';
            }
        }

        function analyzeSound(modal) {
            if (!audioState.isListening || !audioState.analyser) return;
            
            const analyser = audioState.analyser;
            const resultEl = modal.querySelector('#sound-listener-result');
            const canvas = modal.querySelector('#sound-visualizer');
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);
            drawVisualizer(canvas, dataArray, bufferLength);

            let maxVal = -1, maxIndex = -1;
            for (let i = 0; i < bufferLength; i++) {
                if (dataArray[i] > maxVal && dataArray[i] > 180) {
                    maxVal = dataArray[i];
                    maxIndex = i;
                }
            }

            if (maxIndex !== -1) {
                const freq = maxIndex * audioState.context.sampleRate / analyser.fftSize;
                const charIndex = Math.round((freq - BASE_FREQ) / FREQ_STEP);
                if (charIndex >= 0 && charIndex < CHAR_TO_FREQ_MAP.length) {
                    const char = CHAR_TO_FREQ_MAP[charIndex];
                    if (resultEl.textContent.length === 0 || resultEl.textContent.slice(-1) !== char) {
                        resultEl.textContent += char;
                    }
                }
            }
            audioState.animationFrameId = requestAnimationFrame(() => analyzeSound(modal));
        }

        function drawVisualizer(canvas, dataArray, bufferLength) {
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const WIDTH = canvas.width, HEIGHT = canvas.height;
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-surface');
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            ctx.lineWidth = 2; 
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-primary');
            ctx.beginPath(); 
            let sliceWidth = WIDTH * 1.0 / bufferLength;
            let x = 0;
            for (let i = 0; i < bufferLength; i++) {
                let v = dataArray[i] / 128.0;
                let y = v * HEIGHT / 2;
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
                x += sliceWidth;
            }
            ctx.lineTo(canvas.width, canvas.height / 2);
            ctx.stroke();
        }

        // --- Theme Manager & Background Animation ---
        function initBackgroundAnimation() {
            if (backgroundAnimationId) cancelAnimationFrame(backgroundAnimationId);

            const canvas = DOMElements.backgroundCanvas;
            const ctx = canvas.getContext('2d');
            let particles = [];
            const particleSpeed = 0.5;
            const connectionDistance = 100;
            let mouse = { x: -200, y: -200 };

            const setup = () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                particles = [];
                const numParticles = (canvas.width * canvas.height) / 8000;
                for (let i = 0; i < numParticles; i++) {
                    particles.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        vx: (Math.random() - 0.5) * particleSpeed,
                        vy: (Math.random() - 0.5) * particleSpeed,
                        radius: Math.random() * 1.5 + 1,
                        color: `rgba(170, 100, 255, ${0.2 + Math.random() * 0.3})`
                    });
                }
            };
            
            const draw = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;

                    if (p.x < 0) p.x = canvas.width;
                    if (p.x > canvas.width) p.x = 0;
                    if (p.y < 0) p.y = canvas.height;
                    if (p.y > canvas.height) p.y = 0;

                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    ctx.fillStyle = p.color;
                    ctx.fill();

                    particles.forEach(p2 => {
                        const dist = Math.hypot(p.x - p2.x, p.y - p2.y);
                        if (dist < connectionDistance) {
                            ctx.beginPath();
                            ctx.moveTo(p.x, p.y);
                            ctx.lineTo(p2.x, p2.y);
                            ctx.strokeStyle = `rgba(170, 100, 255, ${1 - (dist / connectionDistance)})`;
                            ctx.lineWidth = 0.5;
                            ctx.stroke();
                        }
                    });

                    const distToMouse = Math.hypot(p.x - mouse.x, p.y - mouse.y);
                    if (distToMouse < connectionDistance * 1.5) {
                        ctx.beginPath();
                        ctx.moveTo(p.x, p.y);
                        ctx.lineTo(mouse.x, mouse.y);
                        ctx.strokeStyle = `rgba(255, 255, 255, ${1 - (distToMouse / (connectionDistance * 1.5))})`;
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                });

                backgroundAnimationId = requestAnimationFrame(draw);
            };

            window.addEventListener('resize', setup);
            window.addEventListener('mousemove', e => {
                mouse.x = e.clientX;
                mouse.y = e.clientY;
            });
            window.addEventListener('mouseout', () => {
                mouse.x = -200;
                mouse.y = -200;
            });

            setup();
            draw();
        }

        function stopBackgroundAnimation() {
            if (backgroundAnimationId) {
                cancelAnimationFrame(backgroundAnimationId);
                backgroundAnimationId = null;
                const canvas = DOMElements.backgroundCanvas;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        }

        function applyTheme(theme) {
            document.documentElement.dataset.theme = theme;
            localStorage.setItem(STORAGE_KEYS.THEME, theme);
            DOMElements.buttons.themeToggle.querySelector('span').textContent = theme === 'dark' ? 'light_mode' : 'dark_mode';
            
            if (theme === 'dark') {
                initBackgroundAnimation();
            } else {
                stopBackgroundAnimation();
            }
        }

        function toggleTheme() {
            const currentTheme = document.documentElement.dataset.theme;
            applyTheme(currentTheme === 'dark' ? 'light' : 'dark');
        }

        // --- App Initialization ---
        document.addEventListener('DOMContentLoaded', () => { 
            resetWizard(); 
            initializeListeners();
            const savedTheme = localStorage.getItem(STORAGE_KEYS.THEME) || 'dark';
            applyTheme(savedTheme);
            renderKeyManagementView();
        });
    </script>
</body>
</html>
