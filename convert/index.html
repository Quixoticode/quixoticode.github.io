<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QConvert - Dateikonverter</title>
    <!-- Tailwind CSS CDN für einfaches Styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter für eine moderne Schriftart -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #000; /* Schwarzer Hintergrund */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            position: relative; /* Für die Positionierung des Canvas */
            overflow: hidden; /* Verhindert Scrollbalken durch Canvas */
        }
        #interactiveBackgroundCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* Platziert den Canvas hinter dem Inhalt */
        }
        .container {
            background-color: rgba(255, 255, 255, 0.95); /* Leicht transparentes Weiß */
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            text-align: center;
            width: 100%;
            max-width: 500px;
            position: relative;
            overflow: hidden;
            z-index: 1; /* Stellt sicher, dass der Container über dem Canvas liegt */
        }
        .version-info {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 0.8em;
            color: #666;
        }
        input[type="file"] {
            display: none; /* Versteckt den Standard-Dateiauswahl-Button */
        }
        .custom-file-upload {
            border: 2px dashed #a78bfa; /* Lila gestrichelte Linie */
            background-color: #ede9fe; /* Helles Lila */
            color: #6d28d9; /* Dunkles Lila */
            padding: 15px 20px;
            border-radius: 10px;
            cursor: pointer;
            display: inline-block;
            margin-top: 20px;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        .custom-file-upload:hover {
            background-color: #ddd6fe; /* Noch helleres Lila beim Hover */
            border-color: #8b5cf6; /* Kräftigeres Lila beim Hover */
        }
        button {
            background-color: #8b5cf6; /* Lila */
            color: white;
            padding: 12px 25px;
            border-radius: 10px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }
        button:hover {
            background-color: #7c3aed; /* Dunkleres Lila beim Hover */
            transform: translateY(-2px);
        }
        button:disabled {
            background-color: #a78bfa; /* Helleres Lila, wenn deaktiviert */
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        .message {
            margin-top: 20px;
            padding: 10px;
            border-radius: 8px;
            font-size: 0.9em;
        }
        .message.info {
            background-color: #e0f2fe; /* Helles Blau */
            color: #0c4a6e; /* Dunkles Blau */
        }
        .message.success {
            background-color: #dcfce7; /* Helles Grün */
            color: #166534; /* Dunkles Grün */
        }
        .message.error {
            background-color: #fee2e2; /* Helles Rot */
            color: #991b1b; /* Dunkles Rot */
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-top: 4px solid #8b5cf6;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
            display: none; /* Standardmäßig versteckt */
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .download-link {
            display: block;
            margin-top: 20px;
            color: #8b5cf6;
            text-decoration: none;
            font-weight: 600;
            transition: color 0.3s ease;
        }
        .download-link:hover {
            color: #7c3aed;
        }
    </style>
</head>
<body>
    <canvas id="interactiveBackgroundCanvas"></canvas>
    <div class="container">
        <!-- Versionsinformationen -->
        <div class="version-info">Version: 1.0.0</div>
        <!-- Hinweis zur lokalen Verarbeitung -->
        <p class="text-gray-600 mb-4 text-sm">
            <strong class="text-purple-700">Wichtiger Hinweis:</strong> Alle Umwandlungen werden direkt auf Ihrem Gerät verarbeitet. Dies bedeutet, dass Ihre Dateien niemals auf einen Server hochgeladen werden. Die Verarbeitungszeit kann je nach Dateigröße und Leistung Ihres Geräts variieren. Audio-/Video-Konvertierungen können besonders lange dauern.
        </p>

        <h1 class="text-3xl font-bold text-gray-800 mb-6">QConvert</h1>

        <div class="mb-4">
            <label for="fileInput" class="custom-file-upload">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
                </svg>
                Datei auswählen
            </label>
            <input type="file" id="fileInput" accept=".png, .jpg, .jpeg, .mp4">
            <p id="fileNameDisplay" class="text-gray-500 mt-2 text-sm"></p>
        </div>

        <div class="mb-6">
            <label for="conversionType" class="block text-gray-700 text-sm font-bold mb-2">
                Umwandlungsart auswählen:
            </label>
            <select id="conversionType" class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline focus:border-purple-500">
                <option value="">Bitte wählen...</option>
                <option value="png-to-jpg">PNG zu JPG</option>
                <option value="jpg-to-png">JPG zu PNG</option>
                <option value="mp4-to-mp3">MP4 zu MP3</option>
            </select>
        </div>

        <button id="convertButton" disabled>Konvertieren</button>

        <div id="loadingSpinner" class="spinner"></div>
        <div id="messageDisplay" class="message hidden"></div>
        <a id="downloadLink" class="download-link hidden" download>Hier herunterladen</a>
    </div>

    <!-- FFmpeg.wasm Bibliothek für Audio/Video-Konvertierung (Version 0.8.4 für bessere Kompatibilität) -->
    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.8.4/dist/ffmpeg.min.js"></script>
    <script>
        // DOM-Elemente abrufen
        const fileInput = document.getElementById('fileInput');
        const fileNameDisplay = document.getElementById('fileNameDisplay');
        const conversionTypeSelect = document.getElementById('conversionType');
        const convertButton = document.getElementById('convertButton');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const messageDisplay = document.getElementById('messageDisplay');
        const downloadLink = document.getElementById('downloadLink');

        let selectedFile = null; // Speichert die aktuell ausgewählte Datei
        let ffmpeg = null; // FFmpeg Instanz

        // --- Interaktiver Hintergrund ---
        const bgCanvas = document.getElementById('interactiveBackgroundCanvas');
        const bgCtx = bgCanvas.getContext('2d');
        let particles = [];
        const numParticles = 100;
        const particleSize = 1.5;
        const particleSpeed = 0.5;
        const connectionDistance = 100;
        let mouse = { x: -100, y: -100 }; // Start außerhalb des Bildschirms

        // Größe des Canvas anpassen
        function resizeCanvas() {
            bgCanvas.width = window.innerWidth;
            bgCanvas.height = window.innerHeight;
        }

        // Partikel initialisieren
        function initParticles() {
            particles = [];
            for (let i = 0; i < numParticles; i++) {
                particles.push({
                    x: Math.random() * bgCanvas.width,
                    y: Math.random() * bgCanvas.height,
                    vx: (Math.random() - 0.5) * particleSpeed,
                    vy: (Math.random() - 0.5) * particleSpeed,
                    color: `rgba(170, 100, 255, ${0.2 + Math.random() * 0.3})` // Lila-Töne, leicht transparent
                });
            }
        }

        // Partikel zeichnen und aktualisieren
        function animateBackground() {
            bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
            bgCtx.fillStyle = '#000'; // Hintergrund des Canvas ist schwarz
            bgCtx.fillRect(0, 0, bgCanvas.width, bgCtx.height);

            particles.forEach(p => {
                // Update Position
                p.x += p.vx;
                p.y += p.vy;

                // Wrap around edges
                if (p.x < 0) p.x = bgCanvas.width;
                if (p.x > bgCanvas.width) p.x = 0;
                if (p.y < 0) p.y = bgCanvas.height;
                if (p.y > bgCanvas.height) p.y = 0;

                // Draw particle
                bgCtx.beginPath();
                bgCtx.arc(p.x, p.y, particleSize, 0, Math.PI * 2);
                bgCtx.fillStyle = p.color;
                bgCtx.fill();

                // Connect to other particles
                particles.forEach(p2 => {
                    const dist = Math.hypot(p.x - p2.x, p.y - p2.y);
                    if (dist < connectionDistance) {
                        bgCtx.beginPath();
                        bgCtx.moveTo(p.x, p.y);
                        bgCtx.lineTo(p2.x, p2.y);
                        bgCtx.strokeStyle = `rgba(170, 100, 255, ${1 - (dist / connectionDistance)})`; // Transparenz basierend auf Distanz
                        bgCtx.lineWidth = 0.5;
                        bgCtx.stroke();
                    }
                });

                // Connect to mouse
                const distToMouse = Math.hypot(p.x - mouse.x, p.y - mouse.y);
                if (distToMouse < connectionDistance * 1.5) { // Größerer Bereich für Mausinteraktion
                    bgCtx.beginPath();
                    bgCtx.moveTo(p.x, p.y);
                    bgCtx.lineTo(mouse.x, mouse.y);
                    bgCtx.strokeStyle = `rgba(255, 255, 255, ${1 - (distToMouse / (connectionDistance * 1.5))})`; // Weiß, Transparenz basierend auf Distanz
                    bgCtx.lineWidth = 1;
                    bgCtx.stroke();
                }
            });

            requestAnimationFrame(animateBackground);
        }

        // Mausposition aktualisieren
        window.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });

        // Mausposition zurücksetzen, wenn Maus den Bereich verlässt
        window.addEventListener('mouseout', () => {
            mouse.x = -100;
            mouse.y = -100;
        });

        // Canvas bei Fenstergrößenänderung anpassen
        window.addEventListener('resize', () => {
            resizeCanvas();
            initParticles(); // Partikel neu initialisieren, um sie an die neue Größe anzupassen
        });

        // Hintergrundanimation starten
        resizeCanvas();
        initParticles();
        animateBackground();

        // --- FFmpeg Initialisierung ---
        // Dies wird nur einmal initialisiert, wenn die Seite geladen wird
        async function loadFFmpeg() {
            if (ffmpeg) return; // Schon geladen
            showMessage('Lade Konvertierungs-Engine (kann einen Moment dauern)...', 'info');
            try {
                // Überprüfen, ob FFmpeg global verfügbar ist, bevor createFFmpeg aufgerufen wird
                if (typeof FFmpeg === 'undefined') {
                    throw new Error('FFmpeg Bibliothek ist nicht geladen oder definiert.');
                }

                // Initialisiert FFmpeg
                // corePath ist wichtig, damit FFmpeg die Worker-Dateien finden kann
                ffmpeg = FFmpeg.createFFmpeg({
                    log: true, // Zeigt FFmpeg-Logs in der Konsole an
                    // Geändert auf Version 0.8.4, die SharedArrayBuffer nicht zwingend benötigt
                    corePath: 'https://unpkg.com/@ffmpeg/core@0.8.4/dist/ffmpeg-core.js'
                });
                // Lädt die FFmpeg-Module
                await ffmpeg.load();
                showMessage('Konvertierungs-Engine geladen. Bereit zur Umwandlung.', 'success');
            } catch (error) {
                console.error('Fehler beim Laden von FFmpeg:', error);
                showMessage('Fehler beim Laden der Konvertierungs-Engine. Dies kann an Browser-Sicherheitseinstellungen liegen (z.B. SharedArrayBuffer oder CORS). Bitte versuchen Sie es erneut oder verwenden Sie einen anderen Browser.', 'error');
                ffmpeg = null; // Setzt ffmpeg auf null, damit ein erneuter Versuch möglich ist
            }
        }

        // --- Allgemeine App-Logik ---

        // Event-Listener für Dateiauswahl
        fileInput.addEventListener('change', (event) => {
            selectedFile = event.target.files[0];
            if (selectedFile) {
                fileNameDisplay.textContent = `Ausgewählte Datei: ${selectedFile.name}`;
                checkFormValidity();
                hideMessageAndDownloadLink();
            } else {
                fileNameDisplay.textContent = '';
                selectedFile = null;
                convertButton.disabled = true;
            }
        });

        // Event-Listener für die Auswahl des Konvertierungstyps
        conversionTypeSelect.addEventListener('change', () => {
            checkFormValidity();
            hideMessageAndDownloadLink();
        });

        // Überprüft, ob der Konvertierungs-Button aktiviert werden soll
        function checkFormValidity() {
            // Button ist nur aktiv, wenn eine Datei und ein Konvertierungstyp ausgewählt sind UND FFmpeg geladen ist (für Audio/Video)
            if (selectedFile && conversionTypeSelect.value !== '') {
                if (['mp4-to-mp3'].includes(conversionTypeSelect.value) && !ffmpeg) {
                    convertButton.disabled = true; // Deaktivieren, wenn FFmpeg für Audio/Video nicht bereit ist
                    showMessage('Bitte warten Sie, bis die Konvertierungs-Engine geladen ist.', 'info');
                } else {
                    convertButton.disabled = false;
                    hideMessageAndDownloadLink(); // Versteckt die Info-Nachricht, wenn der Button aktiviert wird
                }
            } else {
                convertButton.disabled = true;
            }
        }

        // Blendet Nachrichten und Download-Link aus
        function hideMessageAndDownloadLink() {
            messageDisplay.classList.add('hidden');
            downloadLink.classList.add('hidden');
        }

        // Zeigt eine Nachricht an (Erfolg, Info, Fehler)
        function showMessage(text, type) {
            messageDisplay.textContent = text;
            messageDisplay.className = `message ${type}`; // Setzt die Klasse basierend auf dem Typ
            messageDisplay.classList.remove('hidden');
        }

        // Event-Listener für den Konvertierungs-Button
        convertButton.addEventListener('click', async () => {
            if (!selectedFile) {
                showMessage('Bitte wählen Sie zuerst eine Datei aus.', 'error');
                return;
            }
            const conversionType = conversionTypeSelect.value;
            if (conversionType === '') {
                showMessage('Bitte wählen Sie eine Umwandlungsart aus.', 'error');
                return;
            }

            // Deaktiviert den Button und zeigt den Lade-Spinner an
            convertButton.disabled = true;
            loadingSpinner.style.display = 'block';
            hideMessageAndDownloadLink();
            showMessage('Konvertiere Datei...', 'info');

            try {
                const originalFileNameWithoutExt = selectedFile.name.split('.').slice(0, -1).join('.');

                if (conversionType === 'png-to-jpg' || conversionType === 'jpg-to-png') {
                    // Bildkonvertierung
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        const img = new Image();
                        img.onload = () => {
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');

                            canvas.width = img.width;
                            canvas.height = img.height;
                            ctx.drawImage(img, 0, 0);

                            let outputMimeType = '';
                            let outputFileName = '';

                            switch (conversionType) {
                                case 'png-to-jpg':
                                    outputMimeType = 'image/jpeg';
                                    outputFileName = `${originalFileNameWithoutExt}.jpg`;
                                    break;
                                case 'jpg-to-png':
                                    outputMimeType = 'image/png';
                                    outputFileName = `${originalFileNameWithoutExt}.png`;
                                    break;
                            }

                            const dataUrl = canvas.toDataURL(outputMimeType, 0.9);
                            downloadLink.href = dataUrl;
                            downloadLink.download = outputFileName;
                            downloadLink.textContent = `"${outputFileName}" herunterladen`;
                            downloadLink.classList.remove('hidden');

                            showMessage('Konvertierung erfolgreich!', 'success');
                            loadingSpinner.style.display = 'none';
                            convertButton.disabled = false;
                        };
                        img.onerror = () => {
                            showMessage('Fehler beim Laden des Bildes. Ist es ein gültiges Bildformat?', 'error');
                            loadingSpinner.style.display = 'none';
                            convertButton.disabled = false;
                        };
                        img.src = e.target.result;
                    };
                    reader.onerror = () => {
                        showMessage('Fehler beim Lesen der Datei.', 'error');
                        loadingSpinner.style.display = 'none';
                        convertButton.disabled = false;
                    };
                    if (selectedFile.type.startsWith('image/')) {
                        reader.readAsDataURL(selectedFile);
                    } else {
                        showMessage('Dies ist kein unterstütztes Bildformat für diese Konvertierung.', 'error');
                        loadingSpinner.style.display = 'none';
                        convertButton.disabled = false;
                    }

                } else if (conversionType === 'mp4-to-mp3') {
                    // MP4 zu MP3 Konvertierung
                    if (!ffmpeg) {
                        showMessage('Konvertierungs-Engine ist noch nicht geladen. Bitte warten Sie.', 'info');
                        loadingSpinner.style.display = 'none';
                        convertButton.disabled = false;
                        return;
                    }

                    const inputFileName = selectedFile.name;
                    const outputFileName = `${originalFileNameWithoutExt}.mp3`;

                    // Datei in FFmpeg Dateisystem schreiben
                    ffmpeg.FS('writeFile', inputFileName, await FFmpeg.fetchFile(selectedFile));

                    // FFmpeg Kommando ausführen
                    // `-i` für Eingabedatei, `-q:a 0` für beste Audioqualität, `-map a` nur Audio-Stream
                    await ffmpeg.run('-i', inputFileName, '-q:a', '0', '-map', 'a', outputFileName);

                    // Konvertierte Datei lesen
                    const data = ffmpeg.FS('readFile', outputFileName);

                    // Blob und Download-Link erstellen
                    const blob = new Blob([data.buffer], { type: 'audio/mpeg' });
                    const url = URL.createObjectURL(blob);

                    downloadLink.href = url;
                    downloadLink.download = outputFileName;
                    downloadLink.textContent = `"${outputFileName}" herunterladen`;
                    downloadLink.classList.remove('hidden');

                    showMessage('Konvertierung erfolgreich!', 'success');
                    loadingSpinner.style.display = 'none';
                    convertButton.disabled = false;

                } else {
                    showMessage('Ungültige Umwandlungsart ausgewählt.', 'error');
                    loadingSpinner.style.display = 'none';
                    convertButton.disabled = false;
                }

            } catch (error) {
                console.error('Konvertierungsfehler:', error);
                showMessage(`Ein Fehler ist aufgetreten: ${error.message || error}. Stellen Sie sicher, dass die Datei das richtige Format hat und versuchen Sie es erneut.`, 'error');
            } finally {
                // Setzt den Button zurück und versteckt den Spinner
                loadingSpinner.style.display = 'none';
                convertButton.disabled = false;
            }
        });

        // Initialer Check, falls die Seite neu geladen wird und keine Datei ausgewählt ist
        checkFormValidity();

        // FFmpeg beim Laden der Seite initialisieren, sobald alle Ressourcen geladen sind
        window.addEventListener('load', loadFFmpeg);
    </script>
</body>
</html>
